#pragma once

// File auto-generated by StartNewDay

#include <Export.hpp>
#include <Utilities.ipp>

namespace util
{
  namespace day02
  {
    enum UTILITIES_EXPORT Direction
    {
      Forward = 0,
      Up,
      Down,
      Unknown
    };

    struct UTILITIES_EXPORT Instruction
    {
      Direction d{Direction::Unknown};
      int units{0};

      explicit Instruction(const std::string& x)
      {
        const auto tokens = util::Split(x);
        if(tokens.size() == 2)
        {
          // The input string should look like "forward 5".
          if(tokens[0] == "forward")
          {
            this->d = Direction::Forward;
          }
          else if(tokens[0] == "up")
          {
            this->d = Direction::Up;
          }
          else if(tokens[0] == "down")
          {
            this->d = Direction::Down;
          }

          this->units = util::StringTo<int>(tokens[1]).value_or(0);
        }
      }
    };

    struct UTILITIES_EXPORT Submarine
    {
      int x{0};
      int y{0};

      virtual void move(Instruction inst) = 0;

      void doInstructions(const std::vector<Instruction> instructions)
      {
        for(const auto i : instructions)
        {
          this->move(i);
        }
      }
    };

    struct UTILITIES_EXPORT Submarine_pt1 : public Submarine
    {
      virtual void move(Instruction inst) override
      {
        switch(inst.d)
        {
        case Direction::Forward:
          this->x += inst.units;
          break;

          // According to the instructions, y is depth so up would be going in the negative
          // direction and vice versa.
        case Direction::Up:
          this->y -= inst.units;
          break;
        case Direction::Down:
          this->y += inst.units;
          break;

        case Direction::Unknown:
        default:
          std::cerr << "Refusing to move in unknown direction\n";
          break;
        }
      }
    };

    struct UTILITIES_EXPORT Submarine_pt2 : public Submarine
    {
      int aim{0};

      virtual void move(Instruction inst) override
      {
        switch(inst.d)
        {
        case Direction::Forward:
          this->x += inst.units;
          this->y += this->aim * inst.units;
          break;

          // y is not modified by up or down for part 2 but the same inverse relationship exists.
        case Direction::Up:
          this->aim -= inst.units;
          break;
        case Direction::Down:
          this->aim += inst.units;
          break;

        case Direction::Unknown:
        default:
          std::cerr << "Refusing to move in unknown direction\n";
          break;
        }
      }
    };
  } // namespace day02
} // namespace util
