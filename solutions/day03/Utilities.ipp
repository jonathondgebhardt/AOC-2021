#pragma once

// File auto-generated by StartNewDay

#include <Export.hpp>
#include <Utilities.ipp>

#include <algorithm>
#include <array>
#include <assert.h>
#include <utility>

namespace util
{
  namespace day03
  {
    int binary2int(const std::string& x)
    {
      auto res = 0;

      for(size_t i = 0, j = x.size() - 1; i < x.size(); ++i, --j)
      {
        res |= ((x[i] == '0' ? 0 : 1) << j);
      }

      return res;
    }

    enum Bit
    {
      Zero = 0,
      One,
      Unknown
    };

    Bit getMostCommonBit(const std::vector<std::string>& x, size_t pos)
    {
      if(!x.empty() && pos <= x.front().size())
      {
        std::array<int, 2> counts = {0, 0};

        for(const auto& str : x)
        {
          if(str[pos] == '1')
          {
            ++counts[Bit::One];
          }
          else
          {
            ++counts[Bit::Zero];
          }
        }

        if(counts[Bit::One] == counts[Bit::Zero])
        {
          return Bit::Unknown;
        }

        return counts[Bit::One] > counts[Bit::Zero] ? Bit::One : Bit::Zero;
      }

      return Bit::Unknown;
    }

    std::pair<int, int> getGammaEpsilon(const std::vector<std::string>& x)
    {
      if(!x.empty())
      {
        const auto size = x.front().size();
        auto gamma = 0;
        auto epsilon = 0;

        const auto gammaStr = std::string();
        const auto epsilonStr = std::string();

        for(size_t i = 0, j = size - 1; i < size; ++i, --j)
        {
          const auto bit = util::day03::getMostCommonBit(x, i);
          assert(bit != util::day03::Bit::Unknown);

          gamma |= ((bit == util::day03::Bit::Zero ? 0 : 1) << j);
          epsilon |= ((bit == util::day03::Bit::Zero ? 1 : 0) << j);
        }

        return {gamma, epsilon};
      }

      return {-1, -1};
    }

    int getOxygenGeneratorRating(const std::vector<std::string>& x)
    {
      if(!x.empty())
      {
        std::vector<std::string> pool;
        std::copy(x.begin(), x.end(), std::back_inserter(pool));

        const auto size = x.front().size();
        for(size_t i = 0, j = size - 1; i < size; ++i, --j)
        {
          const auto bit = util::day03::getMostCommonBit(pool, i);
          const auto bitStr = [](util::day03::Bit b)
          {
            if(b == util::day03::Bit::Unknown)
            {
              return '1';
            }

            return b == util::day03::Bit::Zero ? '0' : '1';
          }(bit);
          pool.erase(std::remove_if(pool.begin(), pool.end(),
                                    [bitStr, i](const auto x) { return x[i] != bitStr; }),
                     pool.end());

          if(pool.size() == 1)
          {
            break;
          }
        }

        assert(pool.size() == 1);
        return util::day03::binary2int(pool.front());
      }

      return -1;
    }

    int getC02ScrubberRating(const std::vector<std::string>& x)
    {
      if(!x.empty())
      {
        std::vector<std::string> pool;
        std::copy(x.begin(), x.end(), std::back_inserter(pool));

        const auto size = x.front().size();
        for(size_t i = 0, j = size - 1; i < size; ++i, --j)
        {
          const auto bit = util::day03::getMostCommonBit(pool, i);
          const auto bitStr = [](util::day03::Bit b)
          {
            if(b == util::day03::Bit::Unknown)
            {
              return '0';
            }

            return b == util::day03::Bit::Zero ? '1' : '0';
          }(bit);
          pool.erase(std::remove_if(pool.begin(), pool.end(),
                                    [bitStr, i](const auto x) { return x[i] != bitStr; }),
                     pool.end());

          if(pool.size() == 1)
          {
            break;
          }
        }

        assert(pool.size() == 1);
        return util::day03::binary2int(pool.front());
      }

      return -1;
    }

  } // namespace day03
} // namespace util
